# AUTOGENERATED! DO NOT EDIT! File to edit: ../../nbs/datasets/02_classical_experiment.ipynb.

# %% auto 0
__all__ = ['create_traj_hammer', 'create_traj_electric', 'create_traj_electric_only_test', 'create_traj_magnetic', 'create_traj',
           'create_traj_mass', 'create_traj_charge', 'hammer_electric_dataset', 'hammer_electric_dataset_double_traj']

# %% ../../nbs/datasets/02_classical_experiment.ipynb 2
import numpy as np

import torch
import math

import jax
import jax.numpy as jnp
from jax import random
jax.config.update('jax_platform_name', 'cpu')

from fastai.vision.all import DataLoaders
from torch.utils.data import TensorDataset, DataLoader as DataLoader_torch

# %% ../../nbs/datasets/02_classical_experiment.ipynb 6
def create_traj_hammer(mass, times):
  """Creates the traj of the hammer action, moves along e_k = 0.5*(e_x+e_y) directions """

  def get_position(mass,time):
    k = 2/(1+3*mass)*time
    xy = jnp.array([k/jnp.sqrt(2), k/jnp.sqrt(2)])
    return xy

  return jax.vmap(get_position, in_axes=(None,0))(mass,times)


def create_traj_electric(mass, charge, times):
  """Creates the traj of the electric action, moves along e_k = 0.5*(e_x+e_y) directions """

  def get_position(mass,charge,time):
    k = charge/(4*mass)*time**2
    xy = jnp.array([k/jnp.sqrt(2), k/jnp.sqrt(2)])
    return xy

  return jax.vmap(get_position, in_axes=(None,None,0))(mass,charge,times)

def create_traj_electric_only_test(mass,charge, times):
  """Creates the traj of the electric action, moves along e_k = 0.5*(e_x+e_y) directions """

  def get_position(mass,charge,time):
    k = charge/(4)*time**2
    xy = jnp.array([k/jnp.sqrt(2), k/jnp.sqrt(2)])
    return xy

  return jax.vmap(get_position, in_axes=(None,None,0))(mass,charge,times)


def create_traj_magnetic(mass, charge, times):
  """Creates the traj of the magnetic effect"""

  def get_position(mass,charge,time):
    theta_0 = 3*jnp.pi/4
    R = 2*mass/(charge*(1+3*mass))
    x = R*jnp.cos(-charge/mass*time+theta_0)+R/jnp.sqrt(2)
    y = R*jnp.sin(-charge/mass*time+theta_0)-R/jnp.sqrt(2)
    xy = jnp.array([x, y])
    return xy


  return jax.vmap(get_position, in_axes=(None,None,0))(mass,charge,times)



def create_traj(times, alpha_1, alpha_2, alpha_ext, num_samples,
                key = 1,
                min_mass = 0.4, 
                max_mass = 1.75,
                min_charge = -1.,
                max_charge = -0.5, 
                return_separate=False):
    """Creates the trajectory of the particles given the alphas, created st size(traj)=R_max~1, traj=[[x1,y1],[x2,y2],...]"""

    masses = jax.random.uniform(key, shape=(num_samples,), minval = min_mass, maxval = max_mass)
    key, subkey = random.split(key)
    charges = jax.random.uniform(subkey, shape=(num_samples,), minval = min_charge, maxval = max_charge)
    
    traj_H = jax.vmap(create_traj_hammer, in_axes=(0,None))(masses, times)
    traj_E = jax.vmap(create_traj_electric, in_axes=(0,0,None))(masses, charges, times)
    traj_M = jax.vmap(create_traj_magnetic, in_axes=(0,0,None))(masses, charges, times)
    
    if return_separate:
        return alpha_1*traj_H + alpha_ext*traj_M, alpha_2*traj_E + alpha_ext*traj_M
    else:
        return alpha_1*traj_H + alpha_2*traj_E + alpha_ext*traj_M


# %% ../../nbs/datasets/02_classical_experiment.ipynb 7
def create_traj_mass(key = 1, times = None, masses = None):
  """Creates the trajectory of the particles given the alphas, created st size(traj)=R_max~1, traj=[[x1,y1],[x2,y2],...]"""

  traj_H = jax.vmap(create_traj_hammer, in_axes=(0,None))(masses, times)  

  return traj_H 


def create_traj_charge(key = 1, times = None, masses = None, charges = None):
  """Creates the trajectory of the particles given the alphas, created st size(traj)=R_max~1, traj=[[x1,y1],[x2,y2],...]"""

  traj_E = jax.vmap(create_traj_electric, in_axes=(0,0,None))(masses, charges, times)  

  return traj_E 

# %% ../../nbs/datasets/02_classical_experiment.ipynb 23
def hammer_electric_dataset(dataset_size=500,
                            size_train = 0.8,
                            BS = 100,
                            key_jax = None,
                            times = np.arange(0.,2,0.1),
                            act_rep_val = 1,
                            device = 'cuda' if torch.cuda.is_available() else 'cpu',
                            dims_concat = False):    

    '''
    Creates a dataset with hammer and electric actions, where the input to the models is a single trajectory. 
    Action representation as one-hot encoding. 

    Note: this is not the same as the dataset in our paper, where the input is two trajectories (see below).
    '''

    if key_jax is None:
        key = jax.random.PRNGKey(1)
    else:
        key = jax.random.PRNGKey(key_jax)
        
    # Hammer action
    trajs_h = create_traj(key,
                        times, 
                            alpha_1 = 1., 
                            alpha_2 = 0, 
                            alpha_ext = 0, 
                            num_samples = math.ceil(dataset_size/2))
    if dims_concat:
        trajs_h = trajs_h.transpose(0,2,1).reshape(int(math.ceil(dataset_size/2)), jnp.size(times)*2)            
    else:
        trajs_h = trajs_h.reshape(int(math.ceil(dataset_size/2)), jnp.size(times)*2)    

    # Electric action
    trajs_e = create_traj(key,
                          times,
                            alpha_1 = 0, 
                            alpha_2 = 1., 
                            alpha_ext = 0, 
                            num_samples = math.ceil(dataset_size/2))
    if dims_concat:
        trajs_e = trajs_e.transpose(0,2,1).reshape(int(math.ceil(dataset_size/2)), jnp.size(times)*2)
    else:
        trajs_e = trajs_e.reshape(int(math.ceil(dataset_size/2)), jnp.size(times)*2)
        
    # Action representation
    a_hammer_rep =  jnp.array([[0, act_rep_val]]*math.ceil(dataset_size/2))   
    a_elec_rep =  jnp.array([[act_rep_val, 0]]*math.ceil(dataset_size/2))

    # Merging dataset
    train_set = (jnp.concatenate([trajs_h, trajs_e], axis=0),
                 jnp.concatenate([a_hammer_rep, a_elec_rep], axis=0))
    train_set = jax.device_put(train_set)


    # Shuffle the tensor
    inputs = torch.hstack((torch.tensor(np.array(train_set[0]), dtype=torch.float32),
                           torch.tensor(np.array(train_set[1]), dtype=torch.float32)))
    indices = torch.randperm(inputs.size(0))
    inputs = inputs[indices]

    # Create dataset as inputs (all data) and outputs (only trajectory, no action))
    dataset = TensorDataset(inputs[:int(size_train*dataset_size)].to(device),
                            inputs[:,:-2][:int(size_train*dataset_size)].to(device))    

    # Same for test set
    dataset_test = TensorDataset(inputs[int(size_train*dataset_size):].to(device),
                                inputs[:,:-2][int(size_train*dataset_size):].to(device))  

    # Now define the dataloaders
    loader = DataLoader_torch(dataset, batch_size = BS, shuffle = True)
    loader_test = DataLoader_torch(dataset_test, batch_size = BS, shuffle = True)


    return DataLoaders(loader, loader_test), loader_test, loader

# %% ../../nbs/datasets/02_classical_experiment.ipynb 29
def hammer_electric_dataset_double_traj(dataset_size=500, # Total size of the dataset 
                                        size_train = 0.8, # Proportion of the dataset to be used for training
                                        BS = 100, # Batch size for the dataloaders
                                        key_jax = None, # Seed for the random number generator in JAX
                                        times = np.arange(0.,2,0.1), # Time points for the trajectories
                                        act_rep_val = 1, # Value for the one-hot encoding of the action
                                        alpha_1 = 1., # Alpha for hammer action
                                        alpha_2 = 1., # Alpha for electric action
                                        alpha_ext = 0., # External alpha parameter
                                        device = 'cuda' if torch.cuda.is_available() else 'cpu', # Device to use for computations
                                        min_mass = 0.4, # Minimum mass for the objects
                                        max_mass = 1.75, # Maximum mass for the objects
                                        min_charge = -1.7, # Minimum charge for the objects
                                        max_charge = -0.5, # Maximum charge for the objects
                                        dims_concat = False # Whether to concatenate dimensions
                                        ): 

    '''
    Creates a dataset with hammer and electric actions, where the input to the models is two trajectories (hammer and electric). 
    Action representation as one-hot encoding.
    '''


    assert int(dataset_size/2) == dataset_size/2

    dataset_size = int(dataset_size/2)

    if key_jax is None:
        key = jax.random.PRNGKey(1)
    else:
        key = jax.random.PRNGKey(key_jax)

        
    # Get trajs for both actions (remember to keep alphas at 1)
    trajs_h, trajs_e = create_traj(key = key,
                                    times = times, 
                                    alpha_1 = alpha_1, 
                                    alpha_2 = alpha_2, 
                                    alpha_ext = alpha_ext, 
                                    num_samples = dataset_size,
                                    min_mass = min_mass,
                                    max_mass = max_mass,
                                    min_charge = min_charge,
                                    max_charge = max_charge,
                                    return_separate = True)

    if dims_concat:
        trajs_h = trajs_h.transpose(0,2,1).reshape(dataset_size, jnp.size(times)*2)   
        trajs_e = trajs_e.transpose(0,2,1).reshape(dataset_size, jnp.size(times)*2)         
    else:
        trajs_h = trajs_h.reshape(dataset_size, jnp.size(times)*2)  
        trajs_e = trajs_e.reshape(dataset_size, jnp.size(times)*2) 

    input_trajs = np.concatenate([trajs_h, trajs_e], axis=1)
    inputs = np.vstack([input_trajs, input_trajs]) 

    a_hammer_rep =  np.array([[0, act_rep_val]]*dataset_size)
    a_elec_rep =  np.array([[act_rep_val, 0]]*dataset_size)

    inputs = np.hstack((inputs, np.concatenate([a_hammer_rep, a_elec_rep], axis=0)))

    outputs = np.vstack([trajs_h, trajs_e])

    # Shuffle the tensor
    indices = torch.randperm(inputs.shape[0])
    inputs = torch.tensor(inputs[indices], dtype=torch.float32)
    outputs = torch.tensor(outputs[indices], dtype=torch.float32)

    dataset = TensorDataset(inputs[:int(size_train*dataset_size)].to(device),
                            outputs[:int(size_train*dataset_size)].to(device))  

    dataset_test = TensorDataset(inputs[int(size_train*dataset_size):].to(device),
                                outputs[int(size_train*dataset_size):].to(device))  

    loader = DataLoader_torch(dataset, batch_size = BS, shuffle = True)
    loader_test = DataLoader_torch(dataset_test, batch_size = BS, shuffle = True)

    return DataLoaders(loader, loader_test), loader_test, loader
